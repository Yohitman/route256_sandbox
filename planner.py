'''
Представьте, вы собрали собственный сервер из n
 разнородных процессоров и теперь решили создать для него простейший планировщик задач.

Ваш сервер состоит из n
 процессоров. Но так как процессоры разные, то и достигают они одинаковой скорости работы при разном энергопотреблении. А именно, i
-й процессор в нагрузке тратит ai
 энергии за одну секунду.

Вашему серверу в качестве тестовой нагрузки придет m
 задач. Про каждую задачу вам известны два значения: tj
 и lj
 — момент времени, когда задача j
 придет и время выполнения задачи в секундах.

Для начала вы решили реализовать простейший планировщик, ведущий себя следующим образом: в момент tj
 прихода задачи, вы выбираете свободный процессор с минимальным энергопотреблением и выполняете данную задачу на выбранном процессоре все заданное время. Если к моменту прихода задачи свободных процессоров нет, то вы просто отбрасываете задачу.

Процессор, на котором запущена задача j
 будет занят ровно lj
 секунд, то есть освободится ровно в момент tj+lj
 и в этот же момент уже может быть назначен для выполнения какой-то другой задачи.

Определите суммарное энергопотребление вашего сервера при обработке m
 заданных задач (будем считать, что процессоры в простое не потребляют энергию).

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.

Входные данные
В первой строке заданы два целых числа n
 и m
 (1≤n,m≤3⋅105
) — количество процессоров и задач соответственно.

Во второй строке заданы n
 целых чисел a1,a2,…,an
 (1≤ai≤106
) — энергопотребление соответствующих процессоров под нагрузкой в секунду. Все энергопотребления различны.

В следующих m
 строках заданы описания задач: по одному в строке. В j
-й строке заданы два целых числа tj
 и lj
 (1≤tj≤109
; 1≤lj≤106
) — момент прихода j
-й задачи и время ее выполнения.

Все времена прихода tj
 различны, и задачи заданы в порядке времени прихода.

Выходные данные
Выведите единственное число — суммарное энергопотребление сервера, если потреблением энергии в простое можно пренебречь.
'''

n, m = map(int, input().split())
workflag = dict()
est_time = dict()
result = 0
for proc in map(int, input().split()):
    workflag[proc] = False
    est_time[proc] = 0
prev_time = 0
for tasks in range(m):
    now_time, worktime = map(int, input().split())
    not_working_now = [k for k, v in workflag.items() if v]
    for proc in not_working_now:
        est_time[proc] -= (now_time - prev_time)
        if est_time[proc] <= 0:
            workflag[proc] = False
    prev_time = now_time
    try:
        work_now = min([k for k, v in workflag.items() if not v])
    except ValueError as e:
        work_now = None
    if work_now:
        result += worktime*work_now
        workflag[work_now] = True
        est_time[work_now] = worktime
    else:
        continue
print(result)